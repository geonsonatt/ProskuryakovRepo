# Cписок основных команд git

## Основные команды git

| Команда | Описание |
|---|---|
| `git init` | Инициализирует репозиторий git |
| `git add` | Добавляет файлы в индекс |
| `git commit` | Создает коммит |
| `git push` | Отправляет коммиты на удаленный репозиторий |
| `git pull` | Получает коммиты из удаленного репозитория |
| `git log` | Отображает историю коммитов |
| `git diff` | Отображает различия между коммитами |
| `git checkout` | Переключается на другую ветку |
| `git branch` | Создает или удаляет ветку |
| `git merge` | Объединяет две ветки |
| `git reset` | Отменяет изменения |
| `git stash` | Откладывает изменения |
| `git clean` | Удаляет несвязанные файлы |

## Дополнительные команды git

| Команда | Описание |
|---|---|
| `git remote add` | Добавляет удаленный репозиторий |
| `git fetch` | Получает коммиты из удаленного репозитория |
| `git tag` | Создает или удаляет тэг |
| `git clone` | Создает локальный репозиторий из удаленного |
| `git archive` | Архивирует локальный репозиторий |
| `git format-patch` | Создает патчи из коммитов |
| `git bisect` | Поиск коммитов, вызывающих ошибку |
| `git grep` | Поиск строк в коде |
| `git blame` | Отображение автора и времени создания каждой строки в файле |


## Флаги команды git init

| Флаг | Описание |
|---|---|
| `-q` | `-quiet` | Отображает только ошибки |
| `--bare` | Создает голый репозиторий без рабочей директории |
| `--template=<template-directory>` | Использует указанный шаблон для инициализации репозитория |
| `--separate-git-dir <git-dir>` | Устанавливает отдельный каталог для хранения файлов git |
| `--object-format=<format>` | Устанавливает формат объектов git |
| `-b <branch-name>` | `-initial-branch=<branch-name>` | Создает начальную ветку с указанным именем |
| `--shared[=<permissions>]` | Создает общий репозиторий с указанными правами доступа |
| `<directory>` | Директория, в которой будет создан репозиторий |

## Подробное описание флагов

### Флаг `-q` или `--quiet`

Флаг `-q` или `--quiet` подавляет вывод информации о процессе инициализации репозитория. По умолчанию команда `git init` выводит сообщение о создании репозитория и список файлов, которые были добавлены в индекс.

### Флаг `--bare`

Флаг `--bare` создает голый репозиторий без рабочей директории. Голый репозиторий обычно используется для хранения исходного кода для распределения или размещения в удаленном репозитории.

### Флаг `--template=<template-directory>`

Флаг `--template=<template-directory>` позволяет использовать указанный шаблон для инициализации репозитория. Шаблон - это каталог, который содержит файлы, которые будут скопированы в новый репозиторий.

### Флаг `--separate-git-dir <git-dir>`

Флаг `--separate-git-dir <git-dir>` позволяет установить отдельный каталог для хранения файлов git. По умолчанию файлы git хранятся в подкаталоге `.git` в рабочей директории.

### Флаг `--object-format=<format>`

Флаг `--object-format=<format>` позволяет установить формат объектов git. По умолчанию используется формат `pack-refs`.

### Флаги `-b <branch-name>` или `--initial-branch=<branch-name>`

Флаги `-b <branch-name>` или `--initial-branch=<branch-name>` позволяют создать начальную ветку с указанным именем. По умолчанию создается ветка `master`.

### Флаг `--shared[=<permissions>]`

Флаг `--shared[=<permissions>]` позволяет создать общий репозиторий с указанными правами доступа. Права доступа могут быть указаны в виде восьмеричного числа или в виде символьной строки.

### Флаг `<directory>`

Флаг `<directory>` указывает директорию, в которой будет создан репозиторий. По умолчанию используется текущая директория.

## Флаги команды git add

| Флаг | Описание |
|---|---|
| `-A` | Добавляет все файлы, включая новые и измененные |
| `-u` | Добавляет все измененные файлы |
| `-N` | Не добавляет файлы, которые не были изменены |
| `-p` | Добавляет файлы интерактивно, позволяя вам указать, какие изменения вы хотите включить в коммит |
| `-f` | Добавляет файлы, даже если они не отслеживаются |
| `-v` | Отображает подробную информацию о том, какие файлы были добавлены |
| `-n` | Не добавляет файлы, а просто печатает список файлов, которые будут добавлены |
| `-i` | Добавляет файлы интерактивно, позволяя вам изменить сообщения коммитов |

## Подробное описание флагов

### Флаг `-A`

Флаг `-A` добавляет все файлы, включая новые и измененные. Это эквивалентно выполнению `git add .`.

### Флаг `-u`

Флаг `-u` добавляет все измененные файлы. Это эквивалентно выполнению `git add -A` для всех файлов, которые были изменены с момента последнего коммита.

### Флаг `-N`

Флаг `-N` не добавляет файлы, которые не были изменены. Это может быть полезно, если вы хотите добавить только новые файлы или измененные файлы.

### Флаг `-p`

Флаг `-p` добавляет файлы интерактивно, позволяя вам указать, какие изменения вы хотите включить в коммит. Это может быть полезно, если вы хотите разделить изменения на несколько коммитов.

### Флаг `-f`

Флаг `-f` добавляет файлы, даже если они не отслеживаются. Это может быть полезно, если вы хотите добавить файлы, которые не были созданы в текущей рабочей директории.

### Флаг `-v`

Флаг `-v` отображает подробную информацию о том, какие файлы были добавлены. Это может быть полезно для диагностики проблем.

### Флаг `-n`

Флаг `-n` не добавляет файлы, а просто печатает список файлов, которые будут добавлены. Это может быть полезно для проверки того, какие файлы будут добавлены до того, как вы действительно добавите их.

### Флаг `-i`

Флаг `-i` добавляет файлы интерактивно, позволяя вам изменить сообщения коммитов. Это может быть полезно, если вы хотите добавить подробные сообщения коммитов.


## Флаги команды git commit

| Флаг | Описание |
|---|---|
| `-F <file>` | Использует указанный файл для сообщения коммита |
| `-m <message>` | Задает сообщение коммита |
| `-a` | Автоматически добавляет все файлы, которые были изменены или созданы с момента последнего коммита |
| `-u` | Автоматически добавляет все файлы, которые были изменены с момента последнего коммита, в который был включен указанный файл |
| `-v` | Отображает подробную информацию о коммите |
| `-S` | Подписывает коммит с помощью GPG-ключа |
| `-s` | Подписывает коммит с помощью SSH-ключа |
| `-n` | Не создает коммит, а просто печатает сообщение коммита |
| `-i` | Добавляет файлы интерактивно, позволяя вам изменить сообщения коммитов |

## Подробное описание флагов

### Флаг `-F <file>`

Флаг `-F <file>` использует указанный файл для сообщения коммита. Это может быть полезно, если вы хотите использовать предварительно написанное сообщение коммита или если вы хотите включить в сообщение коммита специальные символы, которые не могут быть введены в командной строке.

### Флаг `-m <message>`

Флаг `-m <message>` задает сообщение коммита. Это обязательное поле для команды git commit. Сообщение коммита должно быть кратким и описательным, чтобы другие пользователи могли понять, что было изменено в коммите.

### Флаг `-a`

Флаг `-a` автоматически добавляет все файлы, которые были изменены или созданы с момента последнего коммита. Это может быть полезно, если вы хотите создать коммит для всех изменений в текущей рабочей директории.

### Флаг `-u`

Флаг `-u` автоматически добавляет все файлы, которые были изменены с момента последнего коммита, в который был включен указанный файл. Это может быть полезно, если вы хотите создать коммит для изменений, которые были сделаны в нескольких файлах.

### Флаг `-v`

Флаг `-v` отображает подробную информацию о коммите. Это включает в себя имя автора, дату и время коммита, список измененных файлов и размер изменений.

### Флаг `-S`

Флаг `-S` подписывает коммит с помощью GPG-ключа. Это может быть полезно для обеспечения целостности и аутентичности коммита.

### Флаг `-s`

Флаг `-s` подписывает коммит с помощью SSH-ключа. Это может быть полезно для обеспечения целостности и аутентичности коммита.

### Флаг `-n`

Флаг `-n` не создает коммит, а просто печатает сообщение коммита. Это может быть полезно для проверки того, какое сообщение коммита будет создано, прежде чем вы действительно создадите коммит.

### Флаг `-i`

Флаг `-i` добавляет файлы интерактивно, позволяя вам изменить сообщения коммитов. Это может быть полезно, если вы хотите добавить подробные сообщения коммитов.

## Флаги команды git push

| Флаг | Описание |
|---|---|
| `-f` | Отправляет коммиты, даже если они будут перезаписывать существующие коммиты на удаленном репозитории |
| `--force-with-lease` | Отправляет коммиты, даже если они будут перезаписывать существующие коммиты на удаленном репозитории, но только если у вас есть блокировка на удаленной ветке |
| `-u` | Устанавливает привязку между локальной и удаленной веткой |
| `--set-upstream=<remote-branch>` | Устанавливает указанную удаленную ветку в качестве родительской для локальной ветки |
| `-o` | Указывает удаленный репозиторий, отличный от указанного в конфигурации |
| `-d` | Отправляет удаленную ветку |
| `-n` | Не отправляет коммиты, а просто печатает список коммитов, которые будут отправлены |

## Подробное описание флагов

### Флаг `-f`

Флаг `-f` отправляет коммиты, даже если они будут перезаписывать существующие коммиты на удаленном репозитории. Это может быть полезно, если вы хотите переопределить изменения, внесенные другим пользователем. Однако его следует использовать с осторожностью, поскольку это может привести к потере данных.

### Флаг `--force-with-lease`

Флаг `--force-with-lease` отправляет коммиты, даже если они будут перезаписывать существующие коммиты на удаленном репозитории, но только если у вас есть блокировка на удаленной ветке. Это более безопасный вариант, чем флаг `-f`, поскольку он предотвращает потерю данных, если другой пользователь заблокировал удаленную ветку.

### Флаг `-u`

Флаг `-u` устанавливает привязку между локальной и удаленной веткой. Это означает, что команда git push будет автоматически отправлять изменения из локальной ветки в указанную удаленную ветку.

### Флаг `--set-upstream=<remote-branch>`

Флаг `--set-upstream=<remote-branch>` устанавливает указанную удаленную ветку в качестве родительской для локальной ветки. Это эквивалентно выполнению `git push -u <remote-name> <local-branch>`.

### Флаг `-o`

Флаг `-o` указывает удаленный репозиторий, отличный от указанного в конфигурации. Это может быть полезно, если вы хотите отправить коммиты в другой репозиторий.

### Флаг `-d`

Флаг `-d` отправляет удаленную ветку. Это может быть полезно, если вы хотите удалить удаленную ветку из удаленного репозитория.

### Флаг `-n`

Флаг `-n` не отправляет коммиты, а просто печатает список коммитов, которые будут отправлены. Это может быть полезно для проверки того, какие коммиты будут отправлены перед их фактическим отправлением.

## Флаги команды git pull

| Флаг | Описание |
|---|---|
| `-f` | Применяет изменения из удаленного репозитория, даже если они будут конфликтовать с локальными изменениями |
| `--rebase` | Применяет изменения из удаленного репозитория, используя механизм ребейса |
| `--ff-only` | Применяет изменения из удаленного репозитория, используя механизм fast-forward, если это возможно |
| `--fetch` | Только выполняет команду git fetch |
| `-n` | Не выполняет команду git pull, а просто печатает список изменений, которые будут применены |

## Подробное описание флагов

### Флаг `-f`

Флаг `-f` применяет изменения из удаленного репозитория, даже если они будут конфликтовать с локальными изменениями. Это может быть полезно, если вы хотите переопределить локальные изменения. Однако его следует использовать с осторожностью, поскольку это может привести к потере данных.

### Флаг `--rebase`

Флаг `--rebase` применяет изменения из удаленного репозитория, используя механизм ребейса. Это означает, что изменения из удаленного репозитория будут применены к локальным изменениям, создавая новую ветку. Это может быть полезно, если вы хотите сохранить историю локальных изменений.

### Флаг `--ff-only`

Флаг `--ff-only` применяет изменения из удаленного репозитория, используя механизм fast-forward, если это возможно. Это означает, что изменения из удаленного репозитория будут применены к локальным изменениям, если они представляют собой простое продвижение вперед. Это может быть полезно для ускорения процесса pull.

### Флаг `--fetch`

Флаг `--fetch` только выполняет команду git fetch. Это может быть полезно, если вы хотите обновить локальную копию удаленного репозитория, но не хотите применять изменения к локальным изменениям.

### Флаг `-n`

Флаг `-n` не выполняет команду git pull, а просто печатает список изменений, которые будут применены. Это может быть полезно для проверки того, какие изменения будут применены перед их фактическим применением.

## Флаги команды git log

| Флаг | Описание |
|---|---|
| `-p` | Отображает различия между коммитами |
| `-n` | Отображает только последние `n` коммитов |
| `-r` | Отображает коммиты в обратном хронологическом порядке |
| `-b` | Отображает только коммиты, сделанные в указанной ветке |
| `-a` | Отображает все коммиты, включая те, которые были сделаны в удаленных ветках |
| `-C` | Отображает коммиты, которые относятся к указанному файлу |
| `-S` | Отображает коммиты, которые содержат указанное выражение |
| `-f` | Отображает только коммиты, которые содержат указанное сообщение |
| `-L` | Отображает различия между указанными файлами |
| `-c` | Отображает только хэши коммитов |
| `-M` | Отображает только сообщения коммитов |
| `-s` | Отображает только авторов коммитов |
| `-t` | Отображает только даты и время коммитов |
| `-u` | Отображает только авторов и даты и время коммитов |
| `-v` | Отображает подробную информацию о коммитах |

## Дополнительные флаги

| Флаг | Описание |
|---|---|
| `-oneline` | Отображает коммиты в одной строке |
| `-graph` | Отображает граф коммитов |
| `-G` | Отображает граф коммитов с использованием ASCII-символов |
| `-g` | Отображает граф коммитов с использованием цветов |
| `-F` | Использует указанный файл для форматирования вывода |
| `-w` | Отображает только первые `w` слов из каждого сообщения коммита |
| `-M` | Отображает только сообщения коммитов, которые были изменены по сравнению с предыдущим коммитом |
| `-R` | Отображает коммиты, которые относятся к указанному репозиторию |
| `-z` | Отображает коммиты в шестнадцатеричном формате |
| `-I` | Отображает только коммиты, которые были сделаны в указанном интервале |
| `-X` | Отображает только коммиты, которые не были сделаны в указанном интервале |
| `-O` | Отображает только коммиты, сделанные в указанной дате |
| `-B` | Отображает только коммиты, сделанные до указанной даты |
| `-Z` | Отображает только коммиты, сделанные в указанном интервале времени |
| `-X` | Отображает только коммиты, сделанные не в указанном интервале времени |
| `-F` | Использует указанный файл для форматирования вывода |


| Флаг | Описание | Пример |
|---|---|---|
| `-n` | Отображает только последние `n` коммитов | `git log -n 10` |
| `-r` | Отображает коммиты в обратном хронологическом порядке | `git log -r` |
| `-b` | Отображает только коммиты, сделанные в указанной ветке | `git log -b master` |
| `-a` | Отображает все коммиты, включая те, которые были сделаны в удаленных ветках | `git log -a` |
| `-C` | Отображает коммиты, которые относятся к указанному файлу | `git log -C README.md` |
| `-S` | Отображает коммиты, которые содержат указанное выражение | `git log -S "fix bug"` |
| `-f` | Отображает только коммиты, которые содержат указанное сообщение | `git log -f "Added new feature"` |
| `-L` | Отображает различия между указанными файлами | `git log -L README.md` |
| `-c` | Отображает только хэши коммитов | `git log -c` |
| `-M` | Отображает только сообщения коммитов | `git log -M` |
| `-s` | Отображает только авторов коммитов | `git log -s` |
| `-t` | Отображает только даты и время коммитов | `git log -t` |
| `-u` | Отображает только авторов и даты и время коммитов | `git log -u` |
| `-v` | Отображает подробную информацию о коммитах | `git log -v` |
| `-oneline` | Отображает коммиты в одной строке | `git log -oneline` |
| `-graph` | Отображает граф коммитов | `git log -graph` |
| `-G` | Отображает граф коммитов с использованием ASCII-символов | `git log -G` |
| `-g` | Отображает граф коммитов с использованием цветов | `git log -g` |

## Флаги команды git diff

| Флаг | Описание |
|---|---|
| `-p` | Отображает различия между двумя версиями файла в виде патча |
| `-u` | Отображает различия между двумя версиями файла в виде unified diff |
| `-c` | Отображает различия между двумя версиями файла в виде контекстного diff |
| `-w` | Отображает только первые `w` слов из каждого изменения |
| `-M` | Отображает только изменения, которые были сделаны в сообщениях коммитов |
| `-R` | Отображает различия между двумя версиями каталога |
| `-z` | Отображает различия в шестнадцатеричном формате |
| `-I` | Отображает только изменения, которые были сделаны в указанном интервале |
| `-X` | Отображает только изменения, которые не были сделаны в указанном интервале |
| `-O` | Отображает только изменения, сделанные в указанной дате |
| `-B` | Отображает только изменения, сделанные до указанной даты |
| `-Z` | Отображает только изменения, сделанные в указанном интервале времени |
| `-X` | Отображает только изменения, сделанные не в указанном интервале времени |

**Флаг `-p`**

Флаг `-p` отображает различия между двумя версиями файла в виде патча. Патч - это набор команд, которые можно применить к одной версии файла, чтобы получить другую версию. Это может быть полезно для внесения изменений в файл, не заходя в редактор.

**Флаг `-u`**

Флаг `-u` отображает различия между двумя версиями файла в виде unified diff. Unified diff - это более простой формат diff, чем патч. Он отображает различия в виде списка строк, которые были добавлены, удалены или изменены.

**Флаг `-c`**

Флаг `-c` отображает различия между двумя версиями файла в виде контекстного diff. Контекстный diff отображает различия в виде блоков, которые включают контекст вокруг изменений. Это может быть полезно для понимания, как изменения влияют на код.

**Флаг `-w`**

Флаг `-w` отображает только первые `w` слов из каждого изменения. Это может быть полезно для уменьшения объема вывода.

**Флаг `-M`**

Флаг `-M` отображает только изменения, которые были сделаны в сообщениях коммитов. Это может быть полезно для просмотра изменений, которые были внесены в коммит.

**Флаг `-R`**

Флаг `-R` отображает различия между двумя версиями каталога. Это может быть полезно для просмотра изменений, которые были внесены в каталог.

**Флаг `-z`**

Флаг `-z` отображает различия в шестнадцатеричном формате. Это может быть полезно для просмотра изменений, которые были внесены в двоичный файл.

**Флаг `-I`**

Флаг `-I` отображает только изменения, которые были сделаны в указанном интервале. Интервал задается в формате `YYYY-MM-DD`.

**Флаг `-X`**

Флаг `-X` отображает только изменения, которые не были сделаны в указанном интервале. Интервал задается в формате `YYYY-MM-DD`.

**Флаг `-O`**

Флаг `-O` отображает только изменения, сделанные в указанной дате. Дата задается в формате `YYYY-MM-DD`.

**Флаг `-B`**

Флаг `-B` отображает только изменения, сделанные до указанной даты. Дата задается в формате `YYYY-MM-DD`.

**Флаг `-Z`**

Флаг `-Z` отображает только изменения, сделанные в указанном интервале времени. Интервал задается в формате `HH:MM:SS`.

**Флаг `-X`**

Флаг `-X` отображает только изменения, сделанные не в указанном интервале времени. Интервал задается в формате `HH:MM:SS`.

## Флаги команды git checkout

| Флаг | Описание |
|---|---|
| `-f` | Перезаписывает все изменения в рабочей области |
| `--force-with-lease` | Перезаписывает все изменения в рабочей области, но только если у вас есть блокировка на ветке |
| `--detach` | Переключается на указанную ветку, но не устанавливает ее в качестве текущей ветки |
| `--ours` | Применяет изменения из рабочей области, даже если они конфликтуют с изменениями в удаленной ветке |
| `--theirs` | Применяет изменения из удаленной ветки, даже если они конфликтуют с изменениями в рабочей области |
| `--merge` | Применяет изменения из удаленной ветки, пытаясь разрешить конфликты |
| `--patch` | Применяет изменения из удаленной ветки в виде патча |
| `--no-track` | Отсоединяет указанную ветку от удаленной ветки |
| `--track <remote-branch>` | Настраивает отслеживание указанной ветки за указанной удаленной веткой |

**Флаг `-f`**

Флаг `-f` перезаписывает все изменения в рабочей области, даже если они не были зафиксированы. Это может быть полезно, если вы хотите отменить все изменения, внесенные в рабочую область. Однако его следует использовать с осторожностью, поскольку он может привести к потере данных.

**Флаг `--force-with-lease`**

Флаг `--force-with-lease` перезаписывает все изменения в рабочей области, но только если у вас есть блокировка на ветке. Это более безопасный вариант, чем флаг `-f`, поскольку он предотвращает потерю данных, если другой пользователь заблокировал ветку.

**Флаг `--detach`**

Флаг `--detach` переключается на указанную ветку, но не устанавливает ее в качестве текущей ветки. Это может быть полезно, если вы хотите проверить изменения в ветке, не перемещая текущую ветку.

**Флаг `--ours`**

Флаг `--ours` применяет изменения из рабочей области, даже если они конфликтуют с изменениями в удаленной ветке. Это может быть полезно, если вы хотите сохранить свои изменения, даже если они не совпадают с изменениями в удаленной ветке.

**Флаг `--theirs`**

Флаг `--theirs` применяет изменения из удаленной ветки, даже если они конфликтуют с изменениями в рабочей области. Это может быть полезно, если вы хотите обновить свои изменения, даже если они не совпадают с изменениями в удаленной ветке.

**Флаг `--merge`**

Флаг `--merge` применяет изменения из удаленной ветки, пытаясь разрешить конфликты. Это может быть полезно, если вы хотите объединить свои изменения с изменениями в удаленной ветке.

**Флаг `--patch`**

Флаг `--patch` применяет изменения из удаленной ветки в виде патча. Это может быть полезно, если вы хотите применить изменения из удаленной ветки, не переключаясь на нее.

**Флаг `--no-track`**

Флаг `--no-track` отсоединяет указанную ветку от удаленной ветки. Это может быть полезно, если вы хотите создать новую ветку, которая не отслеживает удаленную ветку.

**Флаг `--track <remote-branch>`**

Флаг `--track <remote-branch>` настраивает отслеживание указанной ветки за указанной удаленной веткой. Это означает, что изменения в удаленной ветке будут автоматически применяться к указанной ветке.

## Флаги команды git branch

| Флаг | Описание |
|---|---|
| `-m <new-branch-name>` | Переименовывает текущую ветку в указанное имя |
| `--force` | Переименовывает текущую ветку, даже если она не пуста |
| `-d <branch-name>` | Удаляет указанную ветку |
| `--force` | Удаляет указанную ветку, даже если она не пуста |
| `-D <branch-name>` | Удаляет указанную ветку, даже если она отслеживает удаленную ветку |
| `-l` | Выводит список всех веток |
| `-r` | Выводит список всех удаленных веток |
| `-a` | Выводит список всех веток, включая удаленные |
| `-b <branch-name> <start-point>` | Создает новую ветку, начиная с указанного коммита |
| `--no-track` | Создает новую ветку, которая не отслеживает удаленную ветку |
| `--track <remote-branch>` | Создает новую ветку, отслеживающую указанную удаленную ветку |

**Флаг `-m <new-branch-name>`**

Флаг `-m <new-branch-name>` переименовывает текущую ветку в указанное имя. Это может быть полезно, если вы хотите изменить название текущей ветки.

**Флаг `--force`**

Флаг `--force` позволяет переименовать текущую ветку, даже если она не пуста. Это может быть полезно, если вы хотите удалить все изменения в рабочей области текущей ветки.

**Флаг `-d <branch-name>`**

Флаг `-d <branch-name>` удаляет указанную ветку. Это может быть полезно, если вы хотите удалить ветку, которая больше не нужна.

**Флаг `--force`**

Флаг `--force` позволяет удалить указанную ветку, даже если она не пуста. Это может быть полезно, если вы хотите удалить все изменения в рабочей области указанной ветки.

**Флаг `-D <branch-name>`**

Флаг `-D <branch-name>` удаляет указанную ветку, даже если она отслеживает удаленную ветку. Это может быть полезно, если вы хотите удалить ветку, которая больше не нужна, и вы не хотите, чтобы она отслеживала удаленную ветку.

**Флаг `-l`**

Флаг `-l` выводит список всех веток. Это может быть полезно, если вы хотите увидеть, какие ветки существуют в вашем репозитории.

**Флаг `-r`**

Флаг `-r` выводит список всех удаленных веток. Это может быть полезно, если вы хотите увидеть, какие ветки существуют в удаленных репозиториях.

**Флаг `-a`**

Флаг `-a` выводит список всех веток, включая удаленные. Это может быть полезно, если вы хотите увидеть все ветки, которые существуют в вашем репозитории и в удаленных репозиториях.

**Флаг `-b <branch-name> <start-point>`**

Флаг `-b <branch-name> <start-point>` создает новую ветку, начиная с указанного коммита. Это может быть полезно, если вы хотите создать новую ветку, основанную на определенном состоянии вашего репозитория.

**Флаг `--no-track`**

Флаг `--no-track` создает новую ветку, которая не отслеживает удаленную ветку. Это может быть полезно, если вы хотите создать новую ветку, которая не будет обновляться автоматически.

**Флаг `--track <remote-branch>`**

Флаг `--track <remote-branch>` создает новую ветку, отслеживающую указанную удаленную ветку. Это означает, что изменения в удаленной ветке будут автоматически применяться к новой ветке.

## Флаги команды git merge

| Флаг | Описание |
|---|---|
| `-s <strategy>` | Указывает стратегию слияния |
| `--no-ff` | Не использует быструю слияние |
| `--ff-only` | Использует только быструю слияние |
| `--no-commit` | Не создает коммит слияния |
| `--no-verify` | Не выполняет проверку коммитов слияния |
| `--allow-unrelated-histories` | Разрешает слияние ветвей с несвязанными историями |
| `--abort-on-conflict` | Прекращает слияние при обнаружении конфликтов |
| `--continue-on-conflict` | Продолжает слияние при обнаружении конфликтов |
| `--edit` | Открывает редактор для разрешения конфликтов |
| `--no-edit` | Не открывает редактор для разрешения конфликтов |
| `--mergetool <tool>` | Использует указанный инструмент для разрешения конфликтов |
| `--tool-option <option>` | Устанавливает опцию для инструмента разрешения конфликтов |
| `--strategy-option <option>` | Устанавливает опцию для стратегии слияния |

**Флаг `-s <strategy>`**

Флаг `-s <strategy>` указывает стратегию слияния. Доступные стратегии:

* `merge` (по умолчанию): пытается слить изменения вручную, если это возможно. Если это невозможно, создает коммит слияния.
* `ours`: применяет изменения из текущей ветки, даже если они конфликтуют с изменениями в другой ветке.
* `theirs`: применяет изменения из другой ветки, даже если они конфликтуют с изменениями в текущей ветке.
* `subtree`: сливает поддеревья из другой ветки в текущую ветку.
* `octopus`: сливает несколько веток в текущую ветку.

**Флаг `--no-ff`**

Флаг `--no-ff` не использует быструю слияние. Быстрая слияние используется, если изменения в двух ветвях могут быть объединены без конфликтов. Если используется быстрая слияние, то создается только один коммит слияния. Если используется флаг `--no-ff`, то создается два коммита: один для изменений в текущей ветке, а другой для изменений в другой ветке.

**Флаг `--ff-only`**

Флаг `--ff-only` использует только быструю слияние. Если изменения в двух ветвях не могут быть объединены без конфликтов, то слияние не выполняется.

**Флаг `--no-commit`**

Флаг `--no-commit` не создает коммит слияния. Это может быть полезно, если вы хотите выполнить слияние вручную.

**Флаг `--no-verify`**

Флаг `--no-verify` не выполняет проверку коммитов слияния. Проверка коммитов слияния проверяет, что изменения в коммите слияния были успешно применены.

**Флаг `--allow-unrelated-histories`**

Флаг `--allow-unrelated-histories` разрешает слияние ветвей с несвязанными историями. Несвязанные истории - это ветви, которые имеют различное происхождение.

**Флаг `--abort-on-conflict`**

Флаг `--abort-on-conflict` прекращает слияние при обнаружении конфликтов. Конфликты возникают, когда изменения в двух ветвях не могут быть объединены без изменения одного из наборов изменений.

**Флаг `--continue-on-conflict`**

Флаг `--continue-on-conflict` продолжает слияние при обнаружении конфликтов. Это может быть полезно, если вы хотите вручную разрешить конфликты.

**Флаг `--edit`**

Флаг `--edit` открывает редактор для разрешения конфликтов.

**Флаг `--no-edit`**

Флаг `--no-edit` не открывает редактор для разрешения конфликтов. Это может быть полезно, если вы хотите разрешить конфликты вручную с помощью другой программы.

**Флаг `--mergetool <tool>`**

Флаг `--mergetool <tool>` использует указанный инструмент для разрешения конфликтов.

**Флаг `--tool-option <option>`**

Флаг `--tool-option <option>` устанавливает опцию для инструмента разрешения конфликтов.

## Флаги команды git reset

| Флаг | Описание | Пример |
|---|---|---|
| `-soft` | Отменяет все изменения в рабочей области, но сохраняет изменения в индексе | `git reset --soft HEAD~1` |
| `-mixed` | Отменяет все изменения в рабочей области и индексе, но сохраняет изменения в истории | `git reset --mixed HEAD~1` |
| `-hard` | Отменяет все изменения в рабочей области, индексе и истории | `git reset --hard HEAD~1` |
| `--hard <commit>` | Отменяет все изменения в рабочей области, индексе и истории, начиная с указанного коммита | `git reset --hard HEAD~1` |
| `--soft <commit>` | Отменяет все изменения в рабочей области, начиная с указанного коммита, но сохраняет изменения в индексе и истории | `git reset --soft HEAD~1` |
| `--mixed <commit>` | Отменяет все изменения в рабочей области и индексе, начиная с указанного коммита, но сохраняет изменения в истории | `git reset --mixed HEAD~1` |
| `--merge <commit>` | Отменяет все изменения в рабочей области, индексе и истории, начиная с указанного коммита, но сохраняет изменения в истории, которые были внесены в результате слияния | `git reset --merge HEAD~1` |
| `--keep` | Отменяет все изменения в рабочей области, но сохраняет изменения в индексе, даже если они конфликтуют с изменениями в истории | `git reset --keep HEAD~1` |
| `--hard HEAD~1` | Отменяет все изменения в рабочей области, индексе и истории, начиная с коммита `HEAD~1` |
| `--soft HEAD~1` | Отменяет все изменения в рабочей области, начиная с коммита `HEAD~1`, но сохраняет изменения в индексе и истории |
| `--mixed HEAD~1` | Отменяет все изменения в рабочей области и индексе, начиная с коммита `HEAD~1`, но сохраняет изменения в истории |
| `--merge HEAD~1` | Отменяет все изменения в рабочей области, индексе и истории, начиная с коммита `HEAD~1`, но сохраняет изменения в истории, которые были внесены в результате слияния |
| `--keep HEAD~1` | Отменяет все изменения в рабочей области, но сохраняет изменения в индексе, даже если они конфликтуют с изменениями в истории |

**Какие флаги использовать?**

Выбор флага зависит от того, какие изменения вы хотите отменить.

* `-soft` - отменяет все изменения в рабочей области, но сохраняет изменения в индексе. Это означает, что вы можете восстановить изменения в рабочей области, применив их из индекса.
* `-mixed` - отменяет все изменения в рабочей области и индексе, но сохраняет изменения в истории. Это означает, что вы можете восстановить изменения в рабочей области, откатившись на предыдущий коммит.
* `-hard` - отменяет все изменения в рабочей области, индексе и истории. Это означает, что вы не сможете восстановить изменения в рабочей области.

**Какие примеры использования?**

* Если вы случайно изменили файл, но еще не зафиксировали изменения, вы можете использовать флаг `-soft` или `-mixed` для отмены изменений в рабочей области.
* Если вы хотите откатиться на предыдущий коммит, вы можете использовать флаг `-mixed` или `-hard`.
* Если вы хотите отменить изменения, внесенные в результате слияния, вы можете использовать флаг `--merge`.
* Если вы хотите отменить изменения в рабочей области, но сохранить изменения в индексе, даже если они конфликтуют с изменениями в истории, вы можете использовать флаг `--keep`.

## Флаги команды git stash

| Флаг | Описание | Пример |
|---|---|---|
| `-u` | Сохраняет изменения в рабочей области в виде патча | `git stash -u` |
| `-m <message>` | Устанавливает сообщение для stash-объекта | `git stash -m "Сохранение изменений"` |
| `-q` | Отключает вывод сообщений | `git stash -q` |
| `-p` | Позволяет выбрать, какие файлы сохранить в stash-объекте | `git stash -p` |
| `-a` | Сохраняет все изменения в рабочей области, включая изменения, которые не были зафиксированы | `git stash -a` |
| `pop` | Применяет изменения из stash-объекта | `git stash pop` |
| `list` | Выводит список всех stash-объектов | `git stash list` |
| `drop <stash-index>` | Удаляет stash-объект с указанным индексом | `git stash drop 0` |
| `clear` | Удаляет все stash-объекты | `git stash clear` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите использовать команду git stash.

* `-u` - сохраняет изменения в рабочей области в виде патча. Это может быть полезно, если вы хотите сохранить изменения в рабочей области, но не хотите, чтобы они были применены к текущей ветке.
* `-m <message>` - устанавливает сообщение для stash-объекта. Это может быть полезно, чтобы отслеживать, что было сохранено в stash-объекте.
* `-q` - отключает вывод сообщений. Это может быть полезно, если вы хотите использовать команду git stash в сценарии.
* `-p` - позволяет выбрать, какие файлы сохранить в stash-объекте. Это может быть полезно, если вы хотите сохранить только определенные изменения в рабочей области.
* `-a` - сохраняет все изменения в рабочей области, включая изменения, которые не были зафиксированы. Это может быть полезно, если вы хотите сохранить все изменения в рабочей области, прежде чем переключиться на другую ветку.

**Какие примеры использования?**

* Если вы хотите сохранить изменения в рабочей области, но не хотите, чтобы они были применены к текущей ветке, вы можете использовать флаг `-u`. Например, если вы хотите сохранить изменения в файле `README.md`, вы можете выполнить следующую команду:

```
git stash -u README.md
```

* Если вы хотите сохранить изменения в рабочей области и установить сообщение для stash-объекта, вы можете использовать флаги `-u` и `-m`. Например, если вы хотите сохранить изменения в файле `README.md` и установить сообщение "Сохранение изменений в README.md", вы можете выполнить следующую команду:

```
git stash -u README.md -m "Сохранение изменений в README.md"
```

* Если вы хотите сохранить все изменения в рабочей области, включая изменения, которые не были зафиксированы, вы можете использовать флаг `-a`. Например, если вы хотите сохранить все изменения в рабочей области, вы можете выполнить следующую команду:

```
git stash -a
```

* Если вы хотите применить изменения из stash-объекта, вы можете использовать команду `pop`. Например, если вы хотите применить изменения из stash-объекта с индексом 0, вы можете выполнить следующую команду:

```
git stash pop 0
```

* Если вы хотите вывести список всех stash-объектов, вы можете использовать команду `list`. Например, чтобы вывести список всех stash-объектов, вы можете выполнить следующую команду:

```
git stash list
```

* Если вы хотите удалить stash-объект с указанным индексом, вы можете использовать команду `drop`. Например, чтобы удалить stash-объект с индексом 0, вы можете выполнить следующую команду:

```
git stash drop 0
```

* Если вы хотите удалить все stash-объекты, вы можете использовать команду `clear`. Например, чтобы удалить все stash-объекты, вы можете выполнить следующую команду:

```
git stash clear
```
## Флаги команды git clear

| Флаг | Описание | Пример |
|---|---|---|
| `-d` | Удаляет все файлы, которые не отслеживаются Git | `git clean -d` |
| `-f` | Удаляет все файлы, даже если они были зафиксированы | `git clean -f` |
| `-i` | Запрашивает подтверждение перед удалением каждого файла | `git clean -i` |
| `-n` | Выводит список файлов, которые будут удалены, но не удаляет их | `git clean -n` |
| `-x <pattern>` | Удаляет все файлы, имена которых соответствуют указанному шаблону | `git clean -x *.txt` |
| `-X <pattern>` | Не удаляет все файлы, имена которых соответствуют указанному шаблону | `git clean -X *.txt` |

**Какие флаги использовать?**

Выбор флагов зависит от того, какие файлы вы хотите удалить.

* `-d` - удаляет все файлы, которые не отслеживаются Git. Это может быть полезно, если вы хотите освободить место на диске или удалить ненужные файлы.
* `-f` - удаляет все файлы, даже если они были зафиксированы. Это может быть опасно, поэтому следует использовать с осторожностью.
* `-i` - запрашивает подтверждение перед удалением каждого файла. Это может быть полезно, если вы не уверены, какие файлы нужно удалить.
* `-n` - выводит список файлов, которые будут удалены, но не удаляет их. Это может быть полезно для проверки того, какие файлы будут удалены.
* `-x <pattern>` - удаляет все файлы, имена которых соответствуют указанному шаблону. Это может быть полезно, если вы хотите удалить все файлы определенного типа.
* `-X <pattern>` - не удаляет все файлы, имена которых соответствуют указанному шаблону. Это может быть полезно, если вы хотите сохранить все файлы определенного типа.

**Какие примеры использования?**

* Если вы хотите удалить все файлы, которые не отслеживаются Git, вы можете использовать флаг `-d`. Например, чтобы удалить все файлы, которые не отслеживаются Git в текущей рабочей области, вы можете выполнить следующую команду:

```
git clean -d
```

* Если вы хотите удалить все файлы, даже если они были зафиксированы, вы можете использовать флаг `-f`. Например, чтобы удалить все файлы, даже если они были зафиксированы в текущей рабочей области, вы можете выполнить следующую команду:

```
git clean -f
```

* Если вы хотите удалить все файлы, имена которых соответствуют шаблону `*.txt`, вы можете использовать флаг `-x`. Например, чтобы удалить все файлы с расширением `.txt` в текущей рабочей области, вы можете выполнить следующую команду:

```
git clean -x *.txt
```

* Если вы хотите сохранить все файлы с расширением `.txt`, вы можете использовать флаг `-X`. Например, чтобы сохранить все файлы с расширением `.txt` в текущей рабочей области, вы можете выполнить следующую команду:

```
git clean -X *.txt
```

**Безопасность**

Используя команду `git clean`, вы можете потерять важные данные. Поэтому следует использовать ее с осторожностью и создавать резервные копии перед удалением файлов.


# Список флагов для дополнительных команд

## Флаги команды git remote add

| Флаг | Описание | Пример |
|---|---|---|
| `-f` | Перезаписывает существующий удаленный репозиторий с указанным именем | `git remote add -f origin https://github.com/user/repo.git` |
| `--fetch` | Инициализирует fetch-репозиторий | `git remote add --fetch origin https://github.com/user/repo.git` |
| `--push` | Инициализирует push-репозиторий | `git remote add --push origin https://github.com/user/repo.git` |
| `--update` | Обновляет информацию о удаленном репозитории | `git remote add --update origin https://github.com/user/repo.git` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите добавить удаленный репозиторий.

* `-f` - перезаписывает существующий удаленный репозиторий с указанным именем. Это может быть полезно, если вы хотите изменить URL-адрес или имя удаленного репозитория.
* `--fetch` - инициализирует fetch-репозиторий. Это означает, что вы можете получать изменения из удаленного репозитория, но не можете передавать изменения в удаленный репозиторий.
* `--push` - инициализирует push-репозиторий. Это означает, что вы можете передавать изменения в удаленный репозиторий, но не можете получать изменения из удаленного репозитория.
* `--update` - обновляет информацию о удаленном репозитории. Это может быть полезно, если вы хотите обновить URL-адрес или имя удаленного репозитория.

**Какие примеры использования?**

* Если вы хотите добавить удаленный репозиторий с именем `origin` и URL-адресом `https://github.com/user/repo.git`, вы можете выполнить следующую команду:

```
git remote add origin https://github.com/user/repo.git
```

* Если вы хотите перезаписать существующий удаленный репозиторий с именем `origin`, используя URL-адрес `https://github.com/user/repo.git`, вы можете выполнить следующую команду:

```
git remote add -f origin https://github.com/user/repo.git
```

* Если вы хотите добавить удаленный репозиторий с именем `origin`, используя URL-адрес `https://github.com/user/repo.git`, и инициализировать его как fetch-репозиторий, вы можете выполнить следующую команду:

```
git remote add --fetch origin https://github.com/user/repo.git
```

* Если вы хотите добавить удаленный репозиторий с именем `origin`, используя URL-адрес `https://github.com/user/repo.git`, и инициализировать его как push-репозиторий, вы можете выполнить следующую команду:

```
git remote add --push origin https://github.com/user/repo.git
```

* Если вы хотите обновить информацию о удаленном репозитории с именем `origin`, используя URL-адрес `https://github.com/user/repo.git`, вы можете выполнить следующую команду:

```
git remote add --update origin https://github.com/user/repo.git
```
## Флаги команды git fetch

| Флаг | Описание | Пример |
|---|---|---|
| `-q` | Отключает вывод сообщений | `git fetch -q origin` |
| `--all` | Получает изменения со всех удаленных репозиториев | `git fetch --all` |
| `--update-shallow` | Обновляет информацию о удаленных репозиториях с историей по умолчанию | `git fetch --update-shallow origin` |
| `--prune` | Удаляет удаленные ветки, которые больше не отслеживаются | `git fetch --prune origin` |
| `--dry-run` | Выводит список изменений, которые будут получены, но не получает их | `git fetch --dry-run origin` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите получить изменения из удаленного репозитория.

* `-q` - отключает вывод сообщений. Это может быть полезно, если вы хотите использовать команду git fetch в сценарии.
* `--all` - получает изменения со всех удаленных репозиториев. Это может быть полезно, если вы хотите получить изменения из всех удаленных репозиториев, которые вы отслеживаете.
* `--update-shallow` - обновляет информацию о удаленных репозиториях с историей по умолчанию. Это может быть полезно, если вы хотите получить изменения из удаленных репозиториев, которые вы отслеживаете в режиме shallow.
* `--prune` - удаляет удаленные ветки, которые больше не отслеживаются. Это может быть полезно для очистки списка удаленных веток.
* `--dry-run` - выводит список изменений, которые будут получены, но не получает их. Это может быть полезно для проверки того, какие изменения будут получены.

**Какие примеры использования?**

* Если вы хотите получить изменения из удаленного репозитория с именем `origin`, вы можете выполнить следующую команду:

```
git fetch origin
```

* Если вы хотите получить изменения со всех удаленных репозиториев, вы можете выполнить следующую команду:

```
git fetch --all
```

* Если вы хотите получить изменения из удаленного репозитория с именем `origin` и обновить информацию о нем с историей по умолчанию, вы можете выполнить следующую команду:

```
git fetch --update-shallow origin
```

* Если вы хотите удалить удаленные ветки, которые больше не отслеживаются из удаленного репозитория с именем `origin`, вы можете выполнить следующую команду:

```
git fetch --prune origin
```

* Если вы хотите вывести список изменений, которые будут получены из удаленного репозитория с именем `origin`, вы можете выполнить следующую команду:

```
git fetch --dry-run origin
```

**Безопасность**

Используя команду `git fetch`, вы можете получить изменения из удаленного репозитория, которые могут конфликтовать с изменениями, которые вы уже внесли в текущую ветку. Поэтому следует использовать ее с осторожностью и проверять, нет ли конфликтов перед тем, как их применить.

## Флаги команды git tag

| Флаг | Описание | Пример |
|---|---|---|
| `-a` | Создает аннотированный тег | `git tag -a v1.0.0` |
| `-m <message>` | Устанавливает сообщение для тега | `git tag -a v1.0.0 -m "Выпуск v1.0.0"` |
| `-s <key>` | Подписывает тег с помощью GPG-ключа | `git tag -s v1.0.0 -m "Выпуск v1.0.0" -s /path/to/key` |
| `-f` | Перезаписывает существующий тег | `git tag -f v1.0.0` |
| `-l` | Выводит список всех тегов | `git tag -l` |
| `-d <tag>` | Удаляет тег | `git tag -d v1.0.0` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите создать тег.

* `-a` - создает аннотированный тег. Это самый распространенный тип тега. Аннотация тега содержит сообщение и может быть подписана с помощью GPG-ключа.
* `-m <message>` - устанавливает сообщение для тега. Это сообщение будет отображаться при просмотре тега.
* `-s <key>` - подписывает тег с помощью GPG-ключа. Это позволяет проверить подлинность тега.
* `-f` - перезаписывает существующий тег. Это может быть полезно, если вы хотите изменить сообщение или подпись тега.
* `-l` - выводит список всех тегов. Это может быть полезно для просмотра списка всех тегов в репозитории.
* `-d <tag>` - удаляет тег. Это может быть полезно, если вы хотите удалить старый или ненужный тег.

**Какие примеры использования?**

* Если вы хотите создать аннотированный тег с именем `v1.0.0` и сообщением "Выпуск v1.0.0", вы можете выполнить следующую команду:

```
git tag -a v1.0.0 -m "Выпуск v1.0.0"
```

* Если вы хотите создать аннотированный тег с именем `v1.0.0` и подписать его с помощью GPG-ключа, расположенного в файле `/path/to/key`, вы можете выполнить следующую команду:

```
git tag -a v1.0.0 -m "Выпуск v1.0.0" -s /path/to/key
```

* Если вы хотите перезаписать существующий тег с именем `v1.0.0` новым сообщением "Новый выпуск v1.0.0", вы можете выполнить следующую команду:

```
git tag -f v1.0.0 -m "Новый выпуск v1.0.0"
```

* Если вы хотите вывести список всех тегов в репозитории, вы можете выполнить следующую команду:

```
git tag -l
```

* Если вы хотите удалить тег с именем `v1.0.0`, вы можете выполнить следующую команду:

```
git tag -d v1.0.0
```

**Безопасность**

Используя команду `git tag`, вы можете создать тег, который может использоваться для отслеживания определенных версий вашего кода. Поэтому следует использовать ее с осторожностью и убедиться, что теги, которые вы создаете, являются надежными.

## Флаги команды git clone

| Флаг | Описание | Пример |
|---|---|---|
| `-l` | Создает локальный репозиторий в текущей рабочей области | `git clone https://github.com/user/repo.git` |
| `-b <branch>` | Создает локальную ветку с именем <branch> | `git clone https://github.com/user/repo.git -b develop` |
| `-o <name>` | Создает локальный репозиторий с именем <name> | `git clone https://github.com/user/repo.git -o my-repo` |
| `-depth <depth>` | Скачивает только последние <depth> коммитов | `git clone https://github.com/user/repo.git -depth 10` |
| `-n` | Не скачивает файлы, которые не отслеживаются Git | `git clone https://github.com/user/repo.git -n` |
| `-q` | Отключает вывод сообщений | `git clone https://github.com/user/repo.git -q` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите клонировать репозиторий.

* `-l` - создает локальный репозиторий в текущей рабочей области. Это самый распространенный способ клонировать репозиторий.
* `-b <branch>` - создает локальную ветку с именем <branch>. Это может быть полезно, если вы хотите начать работу с определенной ветви.
* `-o <name>` - создает локальный репозиторий с именем <name>. Это может быть полезно, если вы хотите создать локальный репозиторий с другим именем, чем имя удаленного репозитория.
* `-depth <depth>` - скачивает только последние <depth> коммитов. Это может быть полезно, если вы хотите сэкономить место на диске или если вам не нужны все изменения в репозитории.
* `-n` - не скачивает файлы, которые не отслеживаются Git. Это может быть полезно, если вы хотите клонировать только определенные файлы или папки.
* `-q` - отключает вывод сообщений. Это может быть полезно, если вы хотите клонировать репозиторий в сценарии.

**Какие примеры использования?**

* Если вы хотите клонировать репозиторий с именем `repo` в текущую рабочую область, вы можете выполнить следующую команду:

```
git clone https://github.com/user/repo.git
```

* Если вы хотите клонировать репозиторий с именем `repo` в текущую рабочую область и создать локальную ветку с именем `develop`, вы можете выполнить следующую команду:

```
git clone https://github.com/user/repo.git -b develop
```

* Если вы хотите клонировать репозиторий с именем `repo` в новую папку с именем `my-repo`, вы можете выполнить следующую команду:

```
git clone https://github.com/user/repo.git -o my-repo
```

* Если вы хотите клонировать репозиторий с именем `repo` и скачать только последние 10 коммитов, вы можете выполнить следующую команду:

```
git clone https://github.com/user/repo.git -depth 10
```

* Если вы хотите клонировать репозиторий с именем `repo` и не скачивать файлы, которые не отслеживаются Git, вы можете выполнить следующую команду:

```
git clone https://github.com/user/repo.git -n
```

* Если вы хотите клонировать репозиторий с именем `repo` в сценарии, вы можете выполнить следующую команду:

```
git clone https://github.com/user/repo.git -q
```
## Флаги команды git git archive, git format-patch, git bisect, git grep, git blame 

**Команда `git archive`**

| Флаг | Описание | Пример |
|---|---|---|
| `-o <file>` | Записывает архив в файл <file> | `git archive -o archive.zip HEAD` |
| `-t <treeish>` | Архивирует дерево <treeish> | `git archive -o archive.zip HEAD~1` |
| `-v` | Выводит подробную информацию об архиве | `git archive -ov HEAD` |
| `-c` | Включает в архив все файлы, включая те, которые не отслеживаются Git | `git archive -oc HEAD` |
| `-x <pattern>` | Исключает из архива файлы, имена которых соответствуют шаблону <pattern> | `git archive -ox *.txt HEAD` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите архивировать репозиторий.

* `-o <file>` - записывает архив в файл <file>. Это самый распространенный способ архивировать репозиторий.
* `-t <treeish>` - архивирует дерево <treeish>. Это может быть полезно, если вы хотите архивировать конкретную ветвь или коммит.
* `-v` - выводит подробную информацию об архиве. Это может быть полезно для диагностики проблем с архивом.
* `-c` - включает в архив все файлы, включая те, которые не отслеживаются Git. Это может быть полезно, если вы хотите архивировать все файлы в репозитории.
* `-x <pattern>` - исключает из архива файлы, имена которых соответствуют шаблону <pattern>. Это может быть полезно, если вы хотите архивировать только определенные файлы или папки.

**Какие примеры использования?**

* Если вы хотите архивировать текущий репозиторий в файл `archive.zip`, вы можете выполнить следующую команду:

```
git archive -o archive.zip HEAD
```

* Если вы хотите архивировать ветвь `master` в файл `master.zip`, вы можете выполнить следующую команду:

```
git archive -o master.zip master
```

* Если вы хотите архивировать коммит с идентификатором `123456789`, вы можете выполнить следующую команду:

```
git archive -o commit.zip HEAD~1
```

* Если вы хотите получить подробную информацию об архиве, вы можете выполнить следующую команду:

```
git archive -ov HEAD
```

* Если вы хотите архивировать все файлы в репозитории, включая те, которые не отслеживаются Git, вы можете выполнить следующую команду:

```
git archive -oc HEAD
```

* Если вы хотите исключить из архива все файлы с расширением `.txt`, вы можете выполнить следующую команду:

```
git archive -ox *.txt HEAD
```

**Команда `git format-patch`**

| Флаг | Описание | Пример |
|---|---|---|
| `-M` | Отображает сообщение коммита в формате Markdown | `git format-patch -M HEAD` |
| `-s` | Подписывает патч с помощью GPG-ключа | `git format-patch -s HEAD` |
| `-o <file>` | Записывает патч в файл <file> | `git format-patch -o patch.txt HEAD` |
| `-n` | Не включает в патч индексы | `git format-patch -n HEAD` |
| `-r <range>` | Создает патч для диапазона коммитов | `git format-patch -r HEAD~1..HEAD` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите создать патч.

* `-M` - отображает сообщение коммита в формате Markdown. Это может быть полезно для чтения патчей в текстовом редакторе.
* `-s` - подписывает патч с помощью GPG-ключа. Это позволяет проверить подлинность патча.
* `-o <file>` - записывает патч в файл <file>. Это может быть полезно, если вы хотите сохранить патч в файле.
* `-n` - не включает в патч индексы. Это может быть полезно, если вы хотите уменьшить размер патча.
* `-r <range>` - создает патч для диапазона коммитов. Это может быть полезно, если вы хотите создать патч для нескольких
**Команда `git bisect`**

| Флаг | Описание | Пример |
|---|---|---|
| `-b <branch>` | Начинает бисекцию с ветви <branch> | `git bisect start master HEAD~100` |
| `-f` | Принудительно переходит на следующий коммит | `git bisect f` |
| `-r` | Принудительно переходит на предыдущий коммит | `git bisect r` |
| `-v` | Выводит подробную информацию о бисекции | `git bisect -v` |
| `-y` | Автоматически переходит на следующий коммит | `git bisect -y` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите использовать бисекцию.

* `-b <branch>` - начинает бисекцию с ветви <branch>. Это может быть полезно, если вы хотите начать бисекцию с определенной ветви.
* `-f` - принудительно переходит на следующий коммит. Это может быть полезно, если вы уверены, что ошибка присутствует в следующем коммите.
* `-r` - принудительно переходит на предыдущий коммит. Это может быть полезно, если вы уверены, что ошибка присутствует в предыдущем коммите.
* `-v` - выводит подробную информацию о бисекции. Это может быть полезно для диагностики проблем с бисекцией.
* `-y` - автоматически переходит на следующий коммит. Это может быть полезно, если вы хотите ускорить процесс бисекции.

**Какие примеры использования?**

* Если вы хотите найти коммит, который вызвал ошибку, вы можете выполнить следующую команду:

```
git bisect start master HEAD~100
```

Эта команда начнет бисекцию с ветви `master` и коммитом, который находится на 100 коммитов назад.

* Если вы хотите перейти на следующий коммит, вы можете выполнить следующую команду:

```
git bisect f
```

Эта команда перейдет на следующий коммит, который не вызывает ошибку.

* Если вы хотите перейти на предыдущий коммит, вы можете выполнить следующую команду:

```
git bisect r
```

Эта команда перейдет на предыдущий коммит, который вызывает ошибку.

* Если вы хотите вывести подробную информацию о бисекции, вы можете выполнить следующую команду:

```
git bisect -v
```

Эта команда выведет информацию о текущем коммите, включая сообщение коммита, автора и дату.

* Если вы хотите ускорить процесс бисекции, вы можете выполнить следующую команду:

```
git bisect -y
```

Эта команда автоматически перейдет на следующий коммит, если ошибка не была обнаружена в текущем коммите.

**Команда `git grep`**

| Флаг | Описание | Пример |
|---|---|---|
| `-n` | Выводит номер строки для каждой найденной строки | `git grep -n "foo" file.txt` |
| `-c` | Выводит количество найденных строк | `git grep -c "foo" file.txt` |
| `-i` | Игнорирует регистр | `git grep -i "foo" file.txt` |
| `-E` | Использует расширенные регулярные выражения | `git grep -E "foo|bar" file.txt` |
| `-F` | Использует нерегулярные выражения | `git grep -F "foo|bar" file.txt` |
| `-r` | Ищет в подкаталогах | `git grep -r "foo" .` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите искать строки в коде.

* `-n` - выводит номер строки для каждой найденной строки. Это может быть полезно для отладки.
* `-c` - выводит количество найденных строк. Это может быть полезно для получения общего представления о том, сколько раз встречается строка.
* `-i` - игнорирует регистр. Это может быть полезно, если вы ищете строки, которые не чувствительны к регистру.
* `-E` - использует расширенные регулярные выражения. Это позволяет использовать более мощные возможности поиска.
* `-F` - использует нерегулярные выражения. Это позволяет использовать более мощные возможности поиска, чем расширенные регулярные выражения.
* `-r` - ищет в подкаталогах. Это может быть полезно, если вы хотите искать строки во всех файлах в репозитории.

**Команда `git blame`**

| Флаг | Описание | Пример |
|---|---|---|
| `-L <start>, <end>` | Ограничивает вывод строками в диапазоне <start> и <end> | `git blame -L 1,10 file.txt` |
| `-C` | Отображает автора и время создания каждой строки | `git blame -C file.txt` |
| `-n` | Не выводит имя файла для каждой найденной строки | `git blame -n file.txt` |
| `-s` | Выводит только строки, которые были изменены | `git blame -s file.txt` |

**Какие флаги использовать?**

Выбор флагов зависит от того, как вы хотите отображать автора и время создания каждой строки в файле.

* `-L <start>, <end>` - ограничивает вывод строками в диапазоне <start> и <end>. Это может быть полезно, если вы хотите просмотреть только определенные строки в файле.
* `-C` - отображает автора и время создания каждой строки. Это может быть полезно для отслеживания изменений в файле.
* `-n` - не выводит имя файла для каждой найденной строки. Это может быть полезно, если вы хотите сосредоточиться на авторе и времени создания строк.
* `-s` - выводит только строки, которые были изменены. Это может быть полезно, если вы хотите просмотреть только изменения в файле.

**Какие примеры использования?**

* Если вы хотите просмотреть автора и время создания каждой строки в файле `file.txt`, вы можете выполнить следующую команду:

```
git blame file.txt
```

Эта команда выведет список строк в файле `file.txt`, а также автора и время создания каждой строки.

* Если вы хотите просмотреть только строки в диапазоне от 1 до 10 в файле `file.txt`, вы можете выполнить следующую команду:

```
git blame -L 1,10 file.txt
```

Эта команда выведет список строк в диапазоне от 1 до 10 в файле `file.txt`, а также автора и время создания каждой строки.

* Если вы хотите просмотреть только строки, которые были изменены в файле `file.txt`, вы можете выполнить следующую команду:

```
git blame -s file.txt
```

Эта команда выведет список строк в файле `file.txt`, которые были изменены, а также автора и время создания каждой строки.

# Заключение

Вот такие пироги